import { useCallback, useEffect, useRef, useState } from "react";
import axios from "axios";
import {
  SeriesMarker,
  UTCTimestamp,
  ISeriesApi,
  IChartApi,
  LineStyle,
} from "lightweight-charts";
import { RiskData, ActiveFilters, Prediction, Candle } from "../types";
import { API_URL } from "../constants";
import { TimeUtils } from "../utils/timeUtils";
import {
  calculateSMA,
  calculateEMA,
  analyzeTrend,
  detectPricePatterns,
} from "../utils/technicalIndicators";
interface CandleData {
  time: UTCTimestamp;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number; // âœ… Äá»•i thÃ nh required
}

interface UseDataFetchingProps {
  coin: string;
  interval: string;
  activeFilters: ActiveFilters;
  setRiskData: (data: RiskData | null) => void;
  setLastUpdate: (date: Date) => void;
  setPrediction: (prediction: Prediction | null) => void;
  setIsLoading: (loading: boolean) => void;
  chartInstance: IChartApi | null;
  candleSeriesRef: React.MutableRefObject<ISeriesApi<"Candlestick"> | null>;
  volumeSeriesRef: React.MutableRefObject<ISeriesApi<"Histogram"> | null>;
  detectPatterns: (candles: CandleData[]) => SeriesMarker<UTCTimestamp>[];
  detectChartPatterns: (candles: CandleData[]) => SeriesMarker<UTCTimestamp>[];
  predictPatterns: (candles: CandleData[]) => {
    markers: SeriesMarker<UTCTimestamp>[];
    prediction: Prediction | null;
  };
}

// HÃ m fetch data tá»« backend
const fetchHistoricalDataFromBackend = async (
  coin: string,
  interval: string,
  limit: number = 1000
): Promise<Candle[]> => {
  try {
    const url = `${API_URL}/risk/${coin}?interval=${interval}&limit=${limit}`;
    console.log(`ğŸ” [FETCH] URL: ${url}`);

    const response = await axios.get<RiskData>(url, { timeout: 30000 });

    console.log(`ğŸ“¡ [FETCH] Response status: ${response.status}`);
    console.log(`ğŸ“¡ [FETCH] Has data: ${!!response.data}`);
    console.log(`ğŸ“¡ [FETCH] Has candles: ${!!response.data?.candles}`);
    console.log(`ğŸ“¡ [FETCH] Candles count: ${response.data?.candles?.length}`);

    if (response.data && response.data.candles) {
      console.log(
        `âœ… [FETCH] Backend returned ${response.data.candles.length} candles`
      );

      // ğŸ†• LOG CANDLE INFO
      if (response.data.candles.length > 0) {
        const firstCandle = response.data.candles[0];
        const lastCandle =
          response.data.candles[response.data.candles.length - 1];
        console.log(`ğŸ“Š [FETCH] First candle:`, {
          time: new Date(firstCandle.time),
          open: firstCandle.open,
          close: firstCandle.close,
        });
        console.log(`ğŸ“Š [FETCH] Last candle:`, {
          time: new Date(lastCandle.time),
          open: lastCandle.open,
          close: lastCandle.close,
        });
      }

      return response.data.candles;
    }

    console.warn("[FETCH] Backend returned no candles");
    return [];
  } catch (error) {
    console.error(`âŒ [FETCH] Error:`, error);
    throw error;
  }
};

export function useDataFetching({
  coin,
  interval,
  setRiskData,
  setLastUpdate,
  setPrediction,
  setIsLoading,
  candleSeriesRef,
  chartInstance,
  detectPatterns,
  detectChartPatterns,
  predictPatterns,
}: UseDataFetchingProps) {
  const currentCandleRef = useRef<CandleData | null>(null);
  const wsRef = useRef<WebSocket | null>(null);
  const ma25SeriesRef = useRef<ISeriesApi<"Line"> | null>(null); // âœ… Sá»­a type
  const ma99SeriesRef = useRef<ISeriesApi<"Line"> | null>(null); //
  const [trendAnalysis, setTrendAnalysis] = useState<{
    trend: "BULLISH" | "BEARISH" | "SIDEWAYS";
    strength: number;
    signals: string[];
  } | null>(null);
  const initializeMASeries = useCallback((chart: IChartApi) => {
    if (!chart) return;

    try {
      // Clean up existing series
      if (ma25SeriesRef.current) {
        chart.removeSeries(ma25SeriesRef.current);
      }
      if (ma99SeriesRef.current) {
        chart.removeSeries(ma99SeriesRef.current);
      }

      // Táº¡o MA25 line (mÃ u xanh)
      ma25SeriesRef.current = chart.addLineSeries({
        color: "#2962FF",
        lineWidth: 2,
        lineStyle: LineStyle.Solid,
        title: "MA 25",
        priceScaleId: "right", // âœ… QUAN TRá»ŒNG: DÃ¹ng chung price scale vá»›i candles
        lastValueVisible: true,
        priceLineVisible: false,
      });

      // Táº¡o MA99 line (mÃ u cam)
      ma99SeriesRef.current = chart.addLineSeries({
        color: "#FF6D00",
        lineWidth: 2,
        lineStyle: LineStyle.Solid,
        title: "MA 99",
        priceScaleId: "right", // âœ… QUAN TRá»ŒNG: DÃ¹ng chung price scale vá»›i candles
        lastValueVisible: true,
        priceLineVisible: false,
      });

      console.log("âœ… MA series initialized");
    } catch (error) {
      console.error("Error initializing MA series:", error);
    }
  }, []);

  // âœ… Khá»Ÿi táº¡o MA series khi chart ready
  useEffect(() => {
    if (chartInstance) {
      initializeMASeries(chartInstance);
    }
  }, [chartInstance, initializeMASeries]);

  // âœ… TÃ­nh toÃ¡n vÃ  váº½ MA lines
  const updateMALines = useCallback((candles: CandleData[]) => {
    if (!ma25SeriesRef.current || !ma99SeriesRef.current) {
      console.warn("âŒ MA series not initialized");
      return;
    }

    try {
      console.log(`ğŸ“Š Calculating MA for ${candles.length} candles...`);

      // TÃ­nh MA25 vÃ  MA99
      const ma25Values = calculateSMA(candles, 25);
      const ma99Values = calculateSMA(candles, 99);

      console.log(
        `ğŸ“ˆ MA25 values: ${ma25Values.length}, MA99 values: ${ma99Values.length}`
      );

      if (ma25Values.length === 0 || ma99Values.length === 0) {
        console.warn("âŒ MA calculation returned empty arrays");
        return;
      }

      // âœ… Táº¡o data cho MA lines - Äáº¢M Báº¢O Sá» LÆ¯á»¢NG Báº°NG NHAU
      const ma25Data = candles
        .map((candle, index) => {
          // Náº¿u cÃ³ MA value cho candle nÃ y thÃ¬ dÃ¹ng, khÃ´ng thÃ¬ bá» qua
          if (index < 24) {
            return null; // KhÃ´ng Ä‘á»§ data cho MA25
          }
          const maValue = ma25Values[index];
          return maValue !== null
            ? {
                time: candle.time,
                value: maValue,
              }
            : null;
        })
        .filter((item) => item !== null) as {
        time: UTCTimestamp;
        value: number;
      }[];

      const ma99Data = candles
        .map((candle, index) => {
          // Náº¿u cÃ³ MA value cho candle nÃ y thÃ¬ dÃ¹ng, khÃ´ng thÃ¬ bá» qua
          if (index < 98) {
            return null; // KhÃ´ng Ä‘á»§ data cho MA99
          }
          const maValue = ma99Values[index];
          return maValue !== null
            ? {
                time: candle.time,
                value: maValue,
              }
            : null;
        })
        .filter((item) => item !== null) as {
        time: UTCTimestamp;
        value: number;
      }[];

      console.log(
        `ğŸ“Š MA25 data points: ${ma25Data.length}, MA99 data points: ${ma99Data.length}`
      );

      // âœ… CLEAR DATA TRÆ¯á»šC KHI SET DATA Má»šI
      ma25SeriesRef.current.setData([]);
      ma99SeriesRef.current.setData([]);

      // Set data cho MA lines
      if (ma25Data.length > 0) {
        ma25SeriesRef.current.setData(ma25Data);
      }
      if (ma99Data.length > 0) {
        ma99SeriesRef.current.setData(ma99Data);
      }

      // PhÃ¢n tÃ­ch xu hÆ°á»›ng (chá»‰ khi cÃ³ Ä‘á»§ data)
      if (ma25Data.length >= 2 && ma99Data.length >= 2) {
        const validMa25Values = ma25Values.filter(
          (v) => v !== null
        ) as number[];
        const validMa99Values = ma99Values.filter(
          (v) => v !== null
        ) as number[];

        const trendAnalysis = analyzeTrend(
          candles,
          validMa25Values,
          validMa99Values
        );
        console.log("ğŸ¯ Trend Analysis Result:", trendAnalysis);
        setTrendAnalysis(trendAnalysis);
      } else {
        console.warn("âš ï¸ Not enough MA data for trend analysis");
        setTrendAnalysis({
          trend: "SIDEWAYS",
          strength: 0,
          signals: ["INSUFFICIENT_MA_DATA"],
        });
      }

      console.log(`âœ… MA lines updated successfully`);
    } catch (error) {
      console.error("âŒ Error updating MA lines:", error);
    }
  }, []);
  // âœ… HÃ m fetch data chÃ­nh
  // ğŸ¯ DI CHUYá»‚N HÃ€M combineMarkers RA NGOÃ€I fetchData
  const combineMarkers = useCallback(
    (
      patterns: SeriesMarker<UTCTimestamp>[],
      chartPatterns: SeriesMarker<UTCTimestamp>[],
      predictionMarkers: SeriesMarker<UTCTimestamp>[]
    ): SeriesMarker<UTCTimestamp>[] => {
      const allMarkers = [...predictionMarkers, ...chartPatterns, ...patterns];
      const timeMap = new Map<UTCTimestamp, SeriesMarker<UTCTimestamp>>();

      allMarkers.forEach((marker) => {
        const existing = timeMap.get(marker.time);

        if (!existing) {
          timeMap.set(marker.time, marker);
        } else {
          const existingPriority = getMarkerPriority(existing);
          const newPriority = getMarkerPriority(marker);

          if (newPriority > existingPriority) {
            timeMap.set(marker.time, marker);
          }
        }
      });

      return Array.from(timeMap.values());
    },
    []
  );

  // ğŸ¯ HÃ€M PRIORITY CÅ¨NG DI CHUYá»‚N RA NGOÃ€I
  const getMarkerPriority = (marker: SeriesMarker<UTCTimestamp>): number => {
    const text = marker.text || "";
    if (text.includes("â†‘") || text.includes("â†“")) return 3;
    if (text.includes("H&S") || text.includes("TRI") || text.includes("D-"))
      return 2;
    if (text.includes("BULL") || text.includes("BEAR") || text.includes("DOJI"))
      return 1;
    return 0;
  };
  const createVolumeData = useCallback(
    (
      candles: CandleData[]
    ): { time: UTCTimestamp; value: number; color?: string }[] => {
      return candles.map((candle) => {
        const isBullish = candle.close > candle.open;
        return {
          time: candle.time, // âœ… Äáº£m báº£o lÃ  UTCTimestamp
          value: candle.volume || 0,
          color: isBullish
            ? "rgba(38, 166, 154, 0.8)"
            : "rgba(239, 83, 80, 0.8)",
        };
      });
    },
    []
  );
  const fetchData = useCallback(
    async (forceRefresh = false, historicalYears?: number) => {
      if (!candleSeriesRef.current) return;

      setIsLoading(true);
      try {
        console.log(`ğŸ”„ Fetching data for ${coin} with interval ${interval}`);

        const limit = historicalYears && historicalYears > 0 ? 1000 : 300;
        const candles = await fetchHistoricalDataFromBackend(
          coin,
          interval,
          limit
        );

        if (candles.length === 0) {
          console.warn("No candles received from backend");
          return;
        }

        // Convert to chart data vá»›i timezone correction
        const chartCandles: CandleData[] = candles.map((c) => ({
          time: TimeUtils.toLocalTimestamp(c.time) as UTCTimestamp,
          open: c.open,
          high: c.high,
          low: c.low,
          close: c.close,
          volume: c.volume || 0, // âœ… Äáº£m báº£o cÃ³ volume
        }));

        // âœ… LÆ¯U CURRENT CANDLE Ä‘á»ƒ update real-time
        currentCandleRef.current = chartCandles[chartCandles.length - 1];
        const volumeData = createVolumeData(chartCandles);
        candleSeriesRef.current.setData(chartCandles);
        //volumeSeriesRef.current.setData(volumeData); // âœ… K
        // Táº¡o risk data
        const riskData: RiskData = {
          symbol: coin,
          score: 50,
          flagsMap: {},
          latest: candles[candles.length - 1],
          candles: candles,
          interval,
        };

        setRiskData(riskData);
        setLastUpdate(new Date());

        // Set data lÃªn chart
        candleSeriesRef.current.setData(chartCandles);
        //MA Line draw
        updateMALines(chartCandles);
        // Generate markers cho TOÃ€N Bá»˜ data
        const markers: SeriesMarker<UTCTimestamp>[] = [];
        let combinedMarkers: SeriesMarker<UTCTimestamp>[] = [];
        try {
          const patterns = detectPatterns(chartCandles);
          const chartPatterns = detectChartPatterns(chartCandles);
          const { markers: predictionMarkers, prediction: newPrediction } =
            predictPatterns(chartCandles.slice(-50));

          markers.push(...patterns, ...chartPatterns, ...predictionMarkers);
          //const combinedMarkers = combineMarkers(patterns, chartPatterns, predictionMarkers);
          setPrediction(newPrediction);
          console.log(`Generated ${markers.length} markers`);
          combinedMarkers = combineMarkers(
            patterns,
            chartPatterns,
            predictionMarkers
          );
        } catch (patternError) {
          console.warn("Error in pattern detection:", patternError);
        }

        const limitedMarkers = combinedMarkers.slice(-50);
        candleSeriesRef.current.setMarkers(limitedMarkers);

        console.log(`âœ… Data loaded: ${chartCandles.length} candles`);
      } catch (err) {
        console.error("âŒ Error fetching data:", err);
      } finally {
        setIsLoading(false);
      }
    },
    [
      candleSeriesRef,
      setIsLoading,
      coin,
      interval,
      setRiskData,
      setLastUpdate,
      updateMALines,
      detectPatterns,
      detectChartPatterns,
      createVolumeData,
      predictPatterns,
      setPrediction,
      combineMarkers,
    ]
  );

  // âœ… HÃ m fetch historical data
  const fetchLargeHistoricalData = useCallback(
    async (years: number = 1) => {
      if (!candleSeriesRef.current) {
        console.warn("Chart not initialized");
        return;
      }

      setIsLoading(true);
      console.log(`ğŸ“Š Fetching ${years} years historical data for ${coin}`);

      try {
        // Táº¡m thá»i sá»­ dá»¥ng fetchData vá»›i limit lá»›n
        await fetchData(false, years);
      } catch (error) {
        console.error("âŒ Error in historical data fetch:", error);
      } finally {
        setIsLoading(false);
      }
    },
    [coin, fetchData, candleSeriesRef, setIsLoading]
  );
  // Trong fetchData function

  // âœ… WEBSOCKET - REAL-TIME CURRENT CANDLE UPDATES
  useEffect(() => {
    if (!coin) return;

    // ÄÃ³ng connection cÅ© náº¿u cÃ³
    if (wsRef.current) {
      wsRef.current.close();
    }

    console.log(`ğŸ”Œ Connecting to Binance WebSocket for ${coin}`);

    wsRef.current = new WebSocket(
      `wss://fstream.binance.com/ws/${coin.toLowerCase()}@ticker`
    );

    wsRef.current.onopen = () => {
      console.log(`âœ… Binance WebSocket connected for ${coin}`);
    };

    wsRef.current.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        const currentPrice = parseFloat(data.c);
        const currentVolume = parseFloat(data.v);
        // âœ… CHá»ˆ UPDATE CURRENT CANDLE - giá»‘ng Binance
        if (currentCandleRef.current && candleSeriesRef.current) {
          const updatedCandle = {
            ...currentCandleRef.current,
            high: Math.max(currentCandleRef.current.high, currentPrice),
            low: Math.min(currentCandleRef.current.low, currentPrice),
            close: currentPrice,
          };

          // Update trÃªn chart
          candleSeriesRef.current.update(updatedCandle);
          currentCandleRef.current = updatedCandle;

          // Update last update time
          setLastUpdate(new Date());
        }
      } catch (error) {
        console.error("WebSocket message parse error:", error);
      }
    };

    wsRef.current.onerror = (error) => {
      console.error(`âŒ WebSocket error for ${coin}:`, error);
    };

    wsRef.current.onclose = () => {
      console.log(`ğŸ”Œ WebSocket closed for ${coin}`);
    };

    // Cleanup
    return () => {
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, [coin, candleSeriesRef, setLastUpdate]);

  // âœ… Auto refresh data má»—i phÃºt (chá»‰ data, WebSocket váº«n cháº¡y)
  useEffect(() => {
    const interval = setInterval(() => {
      console.log("ğŸ”„ Auto-refreshing chart data...");
      fetchData();
    }, 60000); // 1 phÃºt

    return () => clearInterval(interval);
  }, [fetchData]);

  return {
    fetchData,
    fetchLargeHistoricalData,
    trendAnalysis,
  };
}
